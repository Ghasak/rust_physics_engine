use core::fmt;
#[allow(unused_imports)]
use num_traits::{Float, FromPrimitive, Num, Zero};
#[allow(unused_imports)]
use std::ops::{Add, Div, Mul, MulAssign, Sub};

#[derive(Debug, Copy, Clone)]
#[allow(dead_code)]
pub struct Vector2d<T> {
    x: T,
    y: T,
}

#[allow(dead_code)]
impl<T> Vector2d<T> {
    pub fn new(x: T, y: T) -> Self {
        Self { x, y }
    }

    pub fn add(self, other: Vector2d<T>) -> Self
    where
        T: Copy + Add<T, Output = T>,
    {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }

    pub fn sub(self, other: Vector2d<T>) -> Self
    where
        T: Sub<T, Output = T> + Copy,
    {
        Self {
            x: self.x - other.x,
            y: self.y - other.y,
        }
    }
    pub fn mul(self, other: Vector2d<T>) -> Self
    where
        T: Mul<T, Output = T> + Copy,
    {
        Self {
            x: self.x * other.x,
            y: self.y * other.y,
        }
    }

    pub fn div(self, other: Self) -> Option<Self>
    where
        T: Div<T, Output = T> + PartialEq + Zero + Copy,
    {
        let zero = T::zero();
        if other.x != zero || other.y != zero {
            Some(Self {
                x: self.x / other.x,
                y: self.y / other.y,
            })
        } else {
            None
        }
    }

    /// Magnitude
    ///
    /// Computes the magnitude of the vector.
    ///
    /// # Concept
    ///
    /// The magnitude of a vector is calculated based on the Pythagorean theorem, which states
    /// that the magnitude of a vector (represented as `(x, y)`) is the square root of the sum of
    /// the squares of its components:
    ///
    /// `magnitude = sqrt((x * x) + (y * y))`
    ///
    /// The magnitude value is returned as a type `T`.
    ///
    /// # Constraints
    ///
    /// The type `T` must implement the `Float`, `Mul`, `Add`, and `Copy` traits.
    ///
    /// # Example
    ///
    /// ```
    /// use vector2d::Vector2d;
    ///
    /// let v = Vector2d::new(3.0, 4.0);
    /// let magnitude = v.magnitude();
    ///
    /// assert_eq!(magnitude, 5.0);
    ///
    pub fn magnitude(self) -> T
    where
        T: Mul<T, Output = T> + Add<T, Output = T> + Float + Copy,
    {
        let x_squared = self.x * self.x;
        let y_squared = self.y * self.y;
        (x_squared + y_squared).sqrt()
    }

    /// Normalize the vector.
    ///
    /// # Examples
    ///
    /// ```
    /// use num_traits::Float;
    /// use std::ops::Div;
    ///
    /// let v = Vector2d::new(3.0, 4.0);
    /// let normalized = v.normalize();
    /// println!("Normalized: {:?}", normalized);
    /// ```
    ///
    /// # Returns
    ///
    /// - If the magnitude of the vector is not zero, it returns a `Result` containing the normalized vector.
    /// - If the magnitude is zero, it returns an `Err` with an error message.
    pub fn normalize(&self) -> Result<Self, String>
    where
        T: Float + Div<T, Output = T> + Copy + FromPrimitive + Zero,
    {
        let m = self.magnitude();
        let zero = T::zero();
        if m != zero {
            //.to_f32().unwrap() {
            Ok(Self {
                x: self.x / m,
                y: self.y / m,
            })
        } else {
            Err("Cannot normalize a zero-length vector.".to_string())
        }
    }

    /// Rotate the vector by a given angle.
    ///
    /// The `rotate` method applies a rotation transformation to the vector
    /// by rotating its coordinates by the specified angle `theta`.
    ///
    /// # Examples
    ///
    /// ```
    /// use num_traits::{Float, FromPrimitive};
    /// use std::ops::{Mul, Sub};
    ///
    /// let v = Vector2d::new(3.0, 4.0);
    /// let rotated = v.rotate(1.0); // Rotate by 1 radian
    /// println!("Rotated: {:?}", rotated);
    /// ```
    ///
    /// # Type Parameters
    ///
    /// - `N`: The type of the angle `theta`.
    ///
    /// # Parameters
    ///
    /// - `theta`: The angle by which to rotate the vector.
    ///
    /// # Returns
    ///
    /// The rotated vector with the coordinates adjusted based on the rotation angle.
    ///
    /// # Constraints
    ///
    /// - `T`: The type of the vector's coordinates, which must support multiplication and subtraction.
    /// - `N`: The type of the angle, which must implement the `Num`, `Float`, and `Sub` traits.
    ///
    pub fn rotate<N>(&self, theta: N) -> Self
    where
        T: Mul<N, Output = T> + Copy + Sub<Output = T> + Add<T, Output = T>,
        N: Num + Float + Sub<Output = T> + Copy + FromPrimitive,
    {
        let cos_theta: N = theta.cos();
        let sin_theta: N = theta.sin();
        Self {
            x: self.x * cos_theta - self.y * sin_theta,
            y: self.x * sin_theta + self.y * cos_theta,
        }
    }

    /// Scale the vector by a given value.
    ///
    /// The `scale` method applies scaling to the vector
    /// by multiply its coordinates by the specified value of `scale`.
    ///
    /// # Examples
    ///
    /// ```
    /// use num_traits::{Float, FromPrimitive};
    /// use std::ops::{Mul, Sub};
    ///
    /// let v = Vector2d::new(3.0, 4.0);
    /// let rotated = v.scale(1.0); // scale by 1 unit
    /// println!("Rotated: {:?}", rotated);
    /// ```
    ///
    /// # Type Parameters
    ///
    /// - `N`: The type of the value of `scale`.
    ///
    /// # Parameters
    ///
    /// - `scale`: The scale by which to scale the vector.
    ///
    /// # Returns
    ///
    /// A new vector with the coordinates adjusted based on the scale value.
    ///
    /// # Constraints
    ///
    /// - `T`: The type of the vector's coordinates, which must support multiplication and subtraction.
    /// - `N`: The type of the scale, which must implement the `Num`, `Float`, and `Sub` traits.
    pub fn scale<U>(&self, scale: U) -> Vector2d<T>
    where
        T: Mul<U, Output = T> + Copy,
        U: Mul<T, Output = T> + Copy,
    {
        Vector2d {
            x: self.x * scale,
            y: self.y * scale,
        }
    }

    pub fn divide_by_scaler<U>(&self, scaler: U) -> VectorResult<T>
    where
        T: Div<U, Output = T> + Copy,
        U: PartialEq + Zero + Copy,
    {
        if scaler == U::zero() {
            let mut error_message = String::new();
            error_message.push_str("[ERROR]: Cannot divide GVector2d type by 0.0 ");
            VectorResult(Err(error_message))
        } else {
            VectorResult(Ok(Self {
                x: self.x / scaler,
                y: self.y / scaler,
            }))
        }
    }

    /// Computes the dot product between two vectors.
    ///
    /// The dot product of two vectors is calculated by multiplying the corresponding
    /// components of the vectors and summing the results.
    ///
    /// # Arguments
    ///
    /// * `self` - The first vector.
    /// * `other` - The second vector.
    ///
    /// # Returns
    ///
    /// The dot product as a value of type `T`.
    ///
    /// # Constraints
    ///
    /// The type `T` must implement the `Mul` trait with `Output = T` and the `Add` trait
    /// with `Output = T`. It must also be `Copy`.
    ///
    /// # Example
    ///
    /// ```
    /// use vector2d::Vector2d;
    ///
    /// let v1 = Vector2d::new(1, 2);
    /// let v2 = Vector2d::new(3, 4);
    /// let dot_product = v1.dot_product(v2);
    ///
    /// assert_eq!(dot_product, 11);
    ///
    pub fn dot_product(self, other: Vector2d<T>) -> T
    where
        T: Mul<Output = T> + Add<Output = T> + Copy,
    {
        self.x * other.x + self.y * other.y
    }
    /// Computes the projection of the vector onto another vector.
    ///
    /// The projection of a vector `self` onto another vector `other` is calculated
    /// by taking the dot product of the two vectors and dividing it by the square
    /// of the magnitude of `other`. The resulting value is then multiplied by `other`
    /// to obtain the projection vector.
    ///
    /// # Arguments
    ///
    /// * `self` - The vector to be projected.
    /// * `other` - The vector onto which `self` is projected.
    ///
    /// # Returns
    ///
    /// The projected vector as a new `Vector2d` instance.
    ///
    /// # Constraints
    ///
    /// The type `T` must implement the `Mul` trait with `Output = T` and be `Copy`.
    ///
    /// # Example
    ///
    /// ```
    /// use vector2d::Vector2d;
    ///
    /// let v = Vector2d::new(3, 4);
    /// let other = Vector2d::new(2, 1);
    /// let projection = v.projection_onto(other);
    ///
    /// assert_eq!(projection, Vector2d::new(1, 2));
    /// ```
    pub fn projection_onto(self, other: Vector2d<T>) -> Self
    where
        T: Mul<Output = T> + Add<Output = T> + Float + Copy,
    {
        let projection_dot = self.dot_product(other);
        let m = other.magnitude() * other.magnitude();
        let temp = projection_dot / m;
        Self {
            x: other.x * temp,
            y: other.y * temp,
        }
    }
    /// Orthogonal Vector
    ///
    /// Calculates the orthogonal vector of `self` with respect to `other`.
    ///
    /// # Concept
    ///
    /// The orthogonal vector of `self` with respect to `other` is obtained by subtracting
    /// the projection of `self` onto `other` from `self`. The projection vector can be
    /// computed using the `projection_onto` method. The resulting vector is orthogonal
    /// (perpendicular) to `other`.
    ///
    /// # Constraints
    ///
    /// - The type `T` must implement the `Mul`, `Add`, `Sub`, `Float`, and `Copy` traits.
    ///
    /// # Example
    ///
    /// ```
    /// use vector2d::Vector2d;
    ///
    /// let v = Vector2d::new(3.0, 4.0);
    /// let w = Vector2d::new(1.0, 1.0);
    /// let orthogonal = v.orthogonal_on(w);
    ///
    /// assert_eq!(orthogonal, Vector2d::new(2.0, 1.0));
    /// ```
    pub fn orthogonal_on(self, other: Vector2d<T>) -> Self
    where
        T: Mul<Output = T> + Add<Output = T> + Float + Copy,
    {
        let projection_vector = self.projection_onto(other);
        self.sub(projection_vector)
    }
}

// ----------------------------------------------------
//        Implemnetation for (+)(-)(/)(*) operators
// ----------------------------------------------------
// ---------- addition (+) -------------
impl<T> Add<Vector2d<T>> for Vector2d<T>
where
    T: Add<T> + Copy,
{
    type Output = Vector2d<T::Output>;
    fn add(self, other: Vector2d<T>) -> Self::Output {
        Vector2d {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

// ---------- subtarction (-) -------------
impl<T> Sub<Vector2d<T>> for Vector2d<T>
where
    T: Sub<T> + Copy,
{
    type Output = Vector2d<T::Output>;
    fn sub(self, other: Vector2d<T>) -> Self::Output {
        Vector2d {
            x: self.x - other.x,
            y: self.y - other.y,
        }
    }
}

// ---------- multiplication (*) -------------
impl<T> Mul<Vector2d<T>> for Vector2d<T>
where
    T: Mul<T> + Copy,
{
    type Output = Vector2d<T::Output>;
    fn mul(self, other: Vector2d<T>) -> Self::Output {
        Vector2d {
            x: self.x * other.x,
            y: self.y * other.y,
        }
    }
}

// ---------- division (/) -------------
impl<T> Div<Vector2d<T>> for Vector2d<T>
where
    T: Div<T, Output = T> + PartialEq + Zero + Copy,
{
    type Output = Option<Vector2d<T>>;

    fn div(self, other: Vector2d<T>) -> Self::Output {
        let zero = T::zero();
        if other.x != zero && other.y != zero {
            Some(Vector2d {
                x: self.x / other.x,
                y: self.y / other.y,
            })
        } else {
            None
        }
    }
}
// -----------------------------------------
//       Implementing the fmt Display
// -----------------------------------------
impl<T> fmt::Display for Vector2d<T>
where
    T: fmt::Display,
{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "<{},{}>", self.x, self.y)
    }
}
// -----------------------------------------
//       Implementing the VectorResult
// -----------------------------------------
/// This will allow us to Get the error immediately, like we defined our own Result
pub struct VectorResult<T>(Result<Vector2d<T>, String>);
impl<T> fmt::Display for VectorResult<T>
where
    Vector2d<T>: fmt::Display,
{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match &self.0 {
            Ok(vector) => write!(f, "{}", vector),
            Err(err) => write!(f, "{}", err),
        }
    }
}

// // -----------------------------------------
// //       Testing Vector 2d Module
// // -----------------------------------------
// #[cfg(test)]
// mod tests {
//     use super::*;
//     use assert_approx_eq::*;
//
//     macro_rules! assert_vec2_equal {
//         ($expected:expr, $actual:expr) => {
//             let tolerance = 0.0001;
//             assert_approx_eq!($expected.x, $actual.x, tolerance);
//             assert_approx_eq!($expected.y, $actual.y, tolerance);
//         };
//     }
//
//     #[test]
//     fn vector_construction() {
//         let v = Vector2d::new(10.0, 20.3);
//         let w = Vector2d::new(20.5, 30.0);
//         let y = v.add(w);
//         let k = Vector2d::add(v, w);
//         println!("Vector construction v -> {v:#?}");
//         println!("Vector construction w -> {w:#?}");
//         println!("also we have {y:#?} and {k:#?}")
//     }
//     #[test]
//     fn vector_basic_operations() {
//         let v = Vector2d::new(10.0 as f32, 20.3 as f32);
//         let w = Vector2d::new(20.5 as f32, 30.0 as f32);
//         let sum = v + w;
//         let expected_output = Vector2d::new(30.5 as f32, 50.3 as f32);
//         assert_vec2_equal!(sum, expected_output);
//     }
// }
